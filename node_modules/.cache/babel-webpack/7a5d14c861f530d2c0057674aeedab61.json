{"ast":null,"code":"import { InjectionToken, NgModule } from '@angular/core';\nimport { Observable } from 'rxjs';\nimport { share } from 'rxjs/operators';\nimport * as io from 'socket.io-client';\nimport io__default from 'socket.io-client';\nimport * as ɵngcc0 from '@angular/core';\n\nclass WrappedSocket {\n  constructor(config) {\n    this.config = config;\n    this.subscribersCounter = {};\n    this.eventObservables$ = {};\n    this.emptyConfig = {\n      url: '',\n      options: {}\n    };\n\n    if (config === undefined) {\n      config = this.emptyConfig;\n    }\n\n    const url = config.url;\n    const options = config.options;\n    const ioFunc = io__default ? io__default : io;\n    this.ioSocket = ioFunc(url, options);\n  }\n\n  of(namespace) {\n    this.ioSocket.of(namespace);\n  }\n\n  on(eventName, callback) {\n    this.ioSocket.on(eventName, callback);\n  }\n\n  once(eventName, callback) {\n    this.ioSocket.once(eventName, callback);\n  }\n\n  connect() {\n    return this.ioSocket.connect();\n  }\n\n  disconnect(_close) {\n    return this.ioSocket.disconnect.apply(this.ioSocket, arguments);\n  }\n\n  emit(_eventName, ..._args) {\n    return this.ioSocket.emit.apply(this.ioSocket, arguments);\n  }\n\n  removeListener(_eventName, _callback) {\n    return this.ioSocket.removeListener.apply(this.ioSocket, arguments);\n  }\n\n  removeAllListeners(_eventName) {\n    return this.ioSocket.removeAllListeners.apply(this.ioSocket, arguments);\n  }\n\n  fromEvent(eventName) {\n    if (!this.subscribersCounter[eventName]) {\n      this.subscribersCounter[eventName] = 0;\n    }\n\n    this.subscribersCounter[eventName]++;\n\n    if (!this.eventObservables$[eventName]) {\n      this.eventObservables$[eventName] = new Observable(observer => {\n        const listener = data => {\n          observer.next(data);\n        };\n\n        this.ioSocket.on(eventName, listener);\n        return () => {\n          this.subscribersCounter[eventName]--;\n\n          if (this.subscribersCounter[eventName] === 0) {\n            this.ioSocket.removeListener(eventName, listener);\n            delete this.eventObservables$[eventName];\n          }\n        };\n      }).pipe(share());\n    }\n\n    return this.eventObservables$[eventName];\n  }\n\n  fromOneTimeEvent(eventName) {\n    return new Promise(resolve => this.once(eventName, resolve));\n  }\n\n}\n/** Socket factory */\n\n\nfunction SocketFactory(config) {\n  return new WrappedSocket(config);\n}\n\nconst SOCKET_CONFIG_TOKEN = new InjectionToken('__SOCKET_IO_CONFIG__');\nlet SocketIoModule = /*#__PURE__*/(() => {\n  class SocketIoModule {\n    static forRoot(config) {\n      return {\n        ngModule: SocketIoModule,\n        providers: [{\n          provide: SOCKET_CONFIG_TOKEN,\n          useValue: config\n        }, {\n          provide: WrappedSocket,\n          useFactory: SocketFactory,\n          deps: [SOCKET_CONFIG_TOKEN]\n        }]\n      };\n    }\n\n  }\n\n  SocketIoModule.ɵfac = function SocketIoModule_Factory(t) {\n    return new (t || SocketIoModule)();\n  };\n\n  SocketIoModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: SocketIoModule\n  });\n  SocketIoModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({});\n  return SocketIoModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { WrappedSocket as Socket, SocketIoModule, SocketFactory as ɵa, SOCKET_CONFIG_TOKEN as ɵb }; //# sourceMappingURL=ngx-socket-io.js.map","map":null,"metadata":{},"sourceType":"module"}